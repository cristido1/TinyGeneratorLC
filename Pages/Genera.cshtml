@page
@model GeneraModel
@{
    ViewData["Title"] = "Genera una storia lunga";
    ViewData["PageDescription"] = "Crea una storia completa con trama, personaggi e capitoli";
}

<div class="note-card" style="max-width:900px; margin-bottom:18px">
    <form id="genForm">
        @Html.AntiForgeryToken()
        <div style="margin-bottom:10px">
            <label for="Prompt" class="note-title">Inserisci il prompt della storia</label>
            <textarea class="keep-input font-monospace" id="Prompt" name="Prompt" rows="8" style="width:100%; padding:10px; font-size:0.95rem;" required>@Model.Prompt</textarea>
        </div>
        <div id="genError" role="alert" style="color:#b00020; margin-bottom:8px; display:none"></div>

        <div style="display:flex; gap:12px; align-items:center; margin-bottom:8px">
            <div style="display:flex; align-items:center; gap:8px;">
                <label for="WriterAgentId" class="note-title" style="margin:0">Scegli writer agent (multi-step)</label>
                <select id="WriterAgentId" name="WriterAgentId" class="keep-input" style="width:320px; padding:8px" required>
                    @foreach (var agent in Model.Agents)
                    {
                        <option value="@agent.Id" selected="@(Model.WriterAgentId == agent.Id ? "selected" : null)">
                            @agent.Name
                            @if (!string.IsNullOrEmpty(agent.MultiStepTemplateName))
                            {
                                <text> [Template: @agent.MultiStepTemplateName]</text>
                            }
                        </option>
                    }
                </select>
            </div>

            <div style="margin-left:auto; display:flex; gap:8px;">
                <button type="button" id="startBtn" class="action-btn primary" style="font-weight:600; padding:8px 14px">Avvia generazione</button>
                <button type="button" id="fullPipelineBtn" class="action-btn" style="font-weight:600; padding:8px 14px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; border:none;">ðŸŽ¬ Pipeline Completo</button>
            </div>
        </div>

        <!-- Progress bar for multi-step -->
        <div id="multiStepProgress" style="display:none; margin-top:12px;">
            <div class="progress" style="height:24px;">
                <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width:0%">
                    Step 0/0
                </div>
            </div>
            <div id="stepStatus" style="margin-top:6px; font-size:0.9em; color:#666;"></div>
        </div>
    </form>
</div>

<hr />
<h2>Stato generazione (live):</h2>
<div id="statusArea">
    <div id="statusPre" class="status-list"><div class="status-msg">Pronto.</div></div>
</div>

<script src="~/lib/signalr/signalr.min.js"></script>
<script>
    const startBtn = document.getElementById('startBtn');
    const statusPre = document.getElementById('statusPre');
    let pollInterval = null;
    let connection = null;

    // helper: fetch and render history for a genId
    async function loadHistory(id) {
        try {
            const p = await fetch(`?handler=progress&id=${encodeURIComponent(id)}`);
            if (!p.ok) return;
            const js = await p.json();
            renderMessages(js.messages);
            if (js.completed) {
                appendMessage('âœ… Completato.');
                if (js.result) appendMessage('Risultato finale (estratto):\n' + js.result.substring(0,1000), 'result');
            }
        } catch (e) { console.error(e); }
    }

    // open a SignalR connection and join a group for genId
    async function connectSignalRAndJoin(genId) {
        try {
            // prefer to reuse the global appSignalR connection if available
            if (window.appSignalR && window.appSignalR.connection) {
                connection = window.appSignalR.connection;
                connection.on('ProgressAppended', (id, message, extraClass) => {
                    if (id !== genId) return;
                    appendMessage(message, extraClass);
                });
                connection.on('ProgressCompleted', (id, finalResult) => {
                    if (id !== genId) return;
                    appendMessage('âœ… Completato.');
                    if (finalResult) appendMessage('Risultato finale (estratto):\n' + (finalResult.substring ? finalResult.substring(0,1000) : finalResult), 'result');
                });
                // Multi-step events
                connection.on('StepProgress', (id, current, max, stepDesc) => {
                    if (id !== genId) return;
                    updateProgressBar(current, max, stepDesc);
                });
                connection.on('StepRetry', (id, retryCount, reason) => {
                    if (id !== genId) return;
                    appendMessage(`ðŸ”„ Retry ${retryCount}: ${reason}`, 'warning');
                });
                connection.on('StepComplete', (id, stepNum) => {
                    if (id !== genId) return;
                    appendMessage(`âœ… Step ${stepNum} completed`, 'success');
                });
                connection.on('TaskComplete', (id, status) => {
                    if (id !== genId) return;
                    hideProgressBar();
                    if (status === 'completed') {
                        appendMessage('âœ… Task completed successfully', 'success');
                    } else if (status === 'failed') {
                        appendMessage('âŒ Task failed', 'error');
                    } else if (status === 'cancelled') {
                        appendMessage('âš ï¸ Task cancelled', 'warning');
                    }
                });
                await window.appSignalR.joinGroup(genId);
                return;
            }
            if (!window.signalR) {
                console.warn('SignalR not available');
                return;
            }
            connection = new signalR.HubConnectionBuilder().withUrl('/progressHub').withAutomaticReconnect().build();

            connection.on('ProgressAppended', (id, message, extraClass) => {
                if (id !== genId) return;
                appendMessage(message, extraClass);
            });
            connection.on('ProgressCompleted', (id, finalResult) => {
                if (id !== genId) return;
                appendMessage('âœ… Completato.');
                if (finalResult) appendMessage('Risultato finale (estratto):\n' + (finalResult.substring ? finalResult.substring(0,1000) : finalResult), 'result');
            });
            // Multi-step events
            connection.on('StepProgress', (id, current, max, stepDesc) => {
                if (id !== genId) return;
                updateProgressBar(current, max, stepDesc);
            });
            connection.on('StepRetry', (id, retryCount, reason) => {
                if (id !== genId) return;
                appendMessage(`ðŸ”„ Retry ${retryCount}: ${reason}`, 'warning');
            });
            connection.on('StepComplete', (id, stepNum) => {
                if (id !== genId) return;
                appendMessage(`âœ… Step ${stepNum} completed`, 'success');
            });
            connection.on('TaskComplete', (id, status) => {
                if (id !== genId) return;
                hideProgressBar();
                if (status === 'completed') {
                    appendMessage('âœ… Task completed successfully', 'success');
                } else if (status === 'failed') {
                    appendMessage('âŒ Task failed', 'error');
                } else if (status === 'cancelled') {
                    appendMessage('âš ï¸ Task cancelled', 'warning');
                }
            });

            await connection.start();
            await connection.invoke('JoinGroup', genId);
        } catch (e) { console.error('SignalR connect error', e); }
    }

    startBtn.addEventListener('click', async () => {
        const prompt = document.getElementById('Prompt').value;
        const genError = document.getElementById('genError');
        if (!prompt || prompt.trim().length === 0) {
            if (genError) {
                genError.textContent = 'Inserisci il prompt';
                genError.style.display = 'block';
            }
            document.getElementById('Prompt').focus();
            return;
        } else if (genError) {
            genError.textContent = '';
            genError.style.display = 'none';
        }

        clearMessages();
        appendMessage('ðŸŸ¡ Avvio...');
    // send start request (include antiforgery token automatically by using the form)
    const form = document.getElementById('genForm');
    const fd = new FormData(form);
    const res = await fetch('?handler=start', { method: 'POST', body: fd });
        if (!res.ok) {
            const text = await res.text();
            appendMessage('Errore avvio: ' + text, 'error');
            return;
        }
        const data = await res.json();
        const id = data.id;
        // persist last gen id so user can come back to page and reconnect
        try { localStorage.setItem('lastGenId', id); } catch { }
        appendMessage('ðŸŸ¢ Generazione avviata. id: ' + id);
        // load history and start SignalR for live updates
        await loadHistory(id);
        await connectSignalRAndJoin(id);
    });

    // Full Pipeline button - generates with all writers, evaluates, selects best, runs full audio pipeline
    const fullPipelineBtn = document.getElementById('fullPipelineBtn');
    fullPipelineBtn.addEventListener('click', async () => {
        const prompt = document.getElementById('Prompt').value;
        const genError = document.getElementById('genError');
        if (!prompt || prompt.trim().length === 0) {
            if (genError) {
                genError.textContent = 'Inserisci il prompt';
                genError.style.display = 'block';
            }
            document.getElementById('Prompt').focus();
            return;
        } else if (genError) {
            genError.textContent = '';
            genError.style.display = 'none';
        }

        clearMessages();
        appendMessage('ðŸŽ¬ Avvio pipeline completo...');
        appendMessage('ðŸ“ VerrÃ  generata una storia con tutti i writer attivi');
        appendMessage('ðŸ” Le storie verranno valutate e la migliore selezionata');
        appendMessage('ðŸ”Š Poi verrÃ  eseguito il pipeline audio completo');

        // send start request for full pipeline
        const form = document.getElementById('genForm');
        const fd = new FormData(form);
        const res = await fetch('?handler=StartFullPipeline', { method: 'POST', body: fd });
        if (!res.ok) {
            const text = await res.text();
            appendMessage('Errore avvio: ' + text, 'error');
            return;
        }
        const data = await res.json();
        const id = data.id;
        // persist last gen id so user can come back to page and reconnect
        try { localStorage.setItem('lastGenId', id); } catch { }
        appendMessage('ðŸŸ¢ Pipeline completo avviato. id: ' + id);
        // load history and start SignalR for live updates
        await loadHistory(id);
        await connectSignalRAndJoin(id);
    });

    // on page load, if there's a lastGenId in localStorage, reattach to it (so the page is persistent)
    (async () => {
        try {
            const existing = localStorage.getItem('lastGenId');
            if (existing) {
                clearMessages();
                appendMessage('ðŸ”„ Ricollegamento alla generazione ' + existing + '...');
                await loadHistory(existing);
                await connectSignalRAndJoin(existing);
            }
        } catch (e) { console.error(e); }
    })();
    // message helpers
    function clearMessages() { statusPre.innerHTML = ''; }
    function appendMessage(msg, extraClass) {
        const el = document.createElement('div');
        el.className = 'status-msg' + (extraClass ? (' ' + extraClass) : '');
        
        // Apply pastel colors for success/error
        if (extraClass === 'success') {
            el.style.backgroundColor = '#d4edda';
            el.style.color = '#155724';
            el.style.padding = '8px';
            el.style.borderRadius = '4px';
            el.style.marginBottom = '4px';
        } else if (extraClass === 'error') {
            el.style.backgroundColor = '#f8d7da';
            el.style.color = '#721c24';
            el.style.padding = '8px';
            el.style.borderRadius = '4px';
            el.style.marginBottom = '4px';
        } else if (extraClass === 'warning') {
            el.style.backgroundColor = '#fff3cd';
            el.style.color = '#856404';
            el.style.padding = '8px';
            el.style.borderRadius = '4px';
            el.style.marginBottom = '4px';
        }
        
        el.textContent = msg;
        statusPre.appendChild(el);
    }
    function renderMessages(messages) { clearMessages(); if (!messages) return; messages.forEach(m => appendMessage(m)); }

    // Progress bar helpers
    function updateProgressBar(current, max, stepDesc) {
        const progressDiv = document.getElementById('multiStepProgress');
        const progressBar = document.getElementById('progressBar');
        const stepStatus = document.getElementById('stepStatus');
        
        if (progressDiv && progressBar && stepStatus) {
            progressDiv.style.display = 'block';
            const pct = Math.round((current / max) * 100);
            progressBar.style.width = pct + '%';
            progressBar.textContent = `Step ${current}/${max}`;
            stepStatus.textContent = stepDesc;
        }
    }

    function hideProgressBar() {
        const progressDiv = document.getElementById('multiStepProgress');
        if (progressDiv) {
            progressDiv.style.display = 'none';
        }
    }

    // hide error when user edits prompt
    const promptInput = document.getElementById('Prompt');
    if (promptInput) {
        promptInput.addEventListener('input', () => {
            const genError = document.getElementById('genError');
            if (genError) { genError.textContent = ''; genError.style.display = 'none'; }
        });
    }
</script>
