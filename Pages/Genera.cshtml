@page
@model GeneraModel
@{
    ViewData["Title"] = "Genera una storia lunga";
    ViewData["PageDescription"] = "Crea una storia completa con trama, personaggi e capitoli";
}

<div class="note-card" style="max-width:900px; margin-bottom:18px">
    <form id="genForm">
        @Html.AntiForgeryToken()
        <div style="margin-bottom:10px">
            <label for="Title" class="note-title">Titolo della storia</label>
            <input class="keep-input font-monospace" id="Title" name="Title" style="width:100%; padding:10px; font-size:0.95rem;" value="@Model.Title" maxlength="120" required />
        </div>
        <div style="margin-bottom:10px">
            <label for="Prompt" class="note-title">Inserisci il prompt della storia</label>
            <textarea class="keep-input font-monospace" id="Prompt" name="Prompt" rows="8" style="width:100%; padding:10px; font-size:0.95rem;" required>@Model.Prompt</textarea>
        </div>
        <div id="savedStories" style="margin-bottom:10px; display:flex; gap:8px; flex-wrap:wrap"></div>
        <div id="genError" role="alert" style="color:#b00020; margin-bottom:8px; display:none"></div>

        <div style="display:flex; gap:12px; align-items:center; margin-bottom:8px">
            <div style="display:flex; align-items:center; gap:8px;">
                <label for="WriterAgentId" class="note-title" style="margin:0">Scegli writer agent (multi-step)</label>
                <select id="WriterAgentId" name="WriterAgentId" class="keep-input" style="width:320px; padding:8px" required>
                    @foreach (var agent in Model.Agents)
                    {
                        <option value="@agent.Id" selected="@(Model.WriterAgentId == agent.Id ? "selected" : null)">
                            @agent.Name
                            @if (!string.IsNullOrEmpty(agent.MultiStepTemplateName))
                            {
                                <text> [Template: @agent.MultiStepTemplateName]</text>
                            }
                        </option>
                    }
                </select>
            </div>

            <div style="margin-left:auto; display:flex; gap:8px;">
                <button type="button" id="startBtn" class="action-btn primary" style="font-weight:600; padding:8px 14px">Avvia generazione</button>
                <button type="button" id="fullPipelineBtn" class="action-btn" style="font-weight:600; padding:8px 14px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; border:none;">ðŸŽ¬ Pipeline Completo</button>
            </div>
        </div>

        <!-- Progress bar for multi-step -->
        <div id="multiStepProgress" style="display:none; margin-top:12px;">
            <div class="progress" style="height:24px;">
                <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width:0%">
                    Step 0/0
                </div>
            </div>
            <div id="stepStatus" style="margin-top:6px; font-size:0.9em; color:#666;"></div>
        </div>
    </form>
</div>

<div class="note-card" style="max-width:900px; margin-bottom:18px">
    <form id="seriesEpisodeForm">
        @Html.AntiForgeryToken()
        <h5 class="note-title" style="margin-bottom:10px">Genera episodio da serie</h5>
        <div style="display:flex; gap:12px; flex-wrap:wrap; margin-bottom:10px;">
            <div style="min-width:260px; flex:1;">
                <label for="SeriesId" class="note-title">Serie</label>
                <select id="SeriesId" name="SeriesId" class="keep-input" style="width:100%; padding:8px" required>
                    @foreach (var s in Model.SeriesList)
                    {
                        <option value="@s.Id" selected="@(Model.SeriesId == s.Id ? "selected" : null)">@s.Titolo</option>
                    }
                </select>
            </div>
            <div style="min-width:220px; flex:1;">
                <label for="EpisodeId" class="note-title">Episodio</label>
                <select id="EpisodeId" name="EpisodeId" class="keep-input" style="width:100%; padding:8px" required></select>
            </div>
            <div style="min-width:260px; flex:1;">
                <label for="SeriesWriterAgentId" class="note-title">Writer agent</label>
                <select id="SeriesWriterAgentId" name="SeriesWriterAgentId" class="keep-input" style="width:100%; padding:8px" required>
                    @foreach (var agent in Model.Agents)
                    {
                        <option value="@agent.Id" selected="@(Model.SeriesWriterAgentId == agent.Id ? "selected" : null)">
                            @agent.Name
                            @if (!string.IsNullOrEmpty(agent.MultiStepTemplateName))
                            {
                                <text> [Template: @agent.MultiStepTemplateName]</text>
                            }
                        </option>
                    }
                </select>
            </div>
        </div>
        <div id="seriesEpisodeError" role="alert" style="color:#b00020; margin-bottom:8px; display:none"></div>
        <div style="display:flex; gap:8px;">
            <button type="button" id="startSeriesEpisodeBtn" class="action-btn primary" style="font-weight:600; padding:8px 14px">Avvia episodio serie</button>
        </div>
    </form>
</div>

<div class="note-card" style="max-width:900px; margin-bottom:18px">
    <form id="stateSeriesEpisodeForm">
        @Html.AntiForgeryToken()
        <h5 class="note-title" style="margin-bottom:10px">Genera episodio (Narrative Engine / state-driven)</h5>
        <div style="display:flex; gap:12px; flex-wrap:wrap; margin-bottom:10px;">
            <div style="min-width:260px; flex:1;">
                <label for="StateSeriesId" class="note-title">Serie</label>
                <select id="StateSeriesId" name="StateSeriesId" class="keep-input" style="width:100%; padding:8px" required>
                    @foreach (var s in Model.SeriesList)
                    {
                        <option value="@s.Id" selected="@(Model.StateSeriesId == s.Id ? "selected" : null)">@s.Titolo</option>
                    }
                </select>
            </div>
            <div style="min-width:220px; flex:1;">
                <label for="StateEpisodeId" class="note-title">Episodio</label>
                <select id="StateEpisodeId" name="StateEpisodeId" class="keep-input" style="width:100%; padding:8px" required></select>
            </div>
            <div style="min-width:260px; flex:1;">
                <label for="StateWriterAgentId" class="note-title">Writer agent</label>
                <select id="StateWriterAgentId" name="StateWriterAgentId" class="keep-input" style="width:100%; padding:8px" required>
                    @foreach (var agent in Model.StateWriterAgents)
                    {
                        <option value="@agent.Id" selected="@(Model.StateWriterAgentId == agent.Id ? "selected" : null)">
                            @agent.Name
                            @if (!string.IsNullOrEmpty(agent.MultiStepTemplateName))
                            {
                                <text> [Template: @agent.MultiStepTemplateName]</text>
                            }
                        </option>
                    }
                </select>
            </div>
            <div style="min-width:160px; flex:0 0 160px;">
                <label for="StateTargetMinutes" class="note-title">Minuti TTS</label>
                <input id="StateTargetMinutes" name="StateTargetMinutes" class="keep-input" style="width:100%; padding:8px" value="@Model.StateTargetMinutes" type="number" min="1" max="120" />
            </div>
        </div>
        <div style="font-size:0.9em; color:#666; margin-bottom:8px">
            Crea una storia state-driven collegata a serie/episodio e accoda il primo chunk. Il profilo narrativo viene preso dalla serie (se impostato) oppure usa il profilo default (id=1).
        </div>
        <div id="stateSeriesEpisodeError" role="alert" style="color:#b00020; margin-bottom:8px; display:none"></div>
        <div style="display:flex; gap:8px;">
            <button type="button" id="startStateSeriesEpisodeBtn" class="action-btn primary" style="font-weight:600; padding:8px 14px">Avvia episodio (state-driven)</button>
            <button type="button" id="startStateSeriesEpisodeAutoBtn" class="action-btn" style="font-weight:600; padding:8px 14px">Avvia episodio completo (~minuti TTS)</button>
        </div>
    </form>
</div>

<div class="note-card" style="max-width:900px; margin-bottom:18px">
    <form id="stateNextChunkForm">
        @Html.AntiForgeryToken()
        <h5 class="note-title" style="margin-bottom:10px">Continua storia (state-driven)</h5>
        <div style="display:flex; gap:12px; flex-wrap:wrap; margin-bottom:10px;">
            <div style="min-width:220px; flex:0 0 220px;">
                <label for="StateStoryId" class="note-title">StoryId</label>
                <input id="StateStoryId" name="StateStoryId" class="keep-input font-monospace" style="width:100%; padding:8px" value="@Model.StateStoryId" placeholder="es. 123" required />
            </div>
            <div style="min-width:260px; flex:1;">
                <label for="StateNextChunkWriterAgentId" class="note-title">Writer agent</label>
                <select id="StateNextChunkWriterAgentId" name="StateNextChunkWriterAgentId" class="keep-input" style="width:100%; padding:8px" required>
                    @foreach (var agent in Model.StateWriterAgents)
                    {
                        <option value="@agent.Id" selected="@(Model.StateNextChunkWriterAgentId == agent.Id ? "selected" : null)">@agent.Name</option>
                    }
                </select>
            </div>
        </div>
        <div style="font-size:0.9em; color:#666; margin-bottom:8px">
            Usa lo StoryId creato dallo start state-driven e genera il chunk successivo.
        </div>
        <div id="stateNextChunkError" role="alert" style="color:#b00020; margin-bottom:8px; display:none"></div>
        <div style="display:flex; gap:8px;">
            <button type="button" id="startStateNextChunkBtn" class="action-btn primary" style="font-weight:600; padding:8px 14px">Genera chunk successivo</button>
        </div>
    </form>
</div>

<hr />
<h2>Stato generazione (live):</h2>
<div id="statusArea">
    <div id="statusPre" class="status-list"><div class="status-msg">Pronto.</div></div>
</div>

<script src="~/lib/signalr/signalr.min.js"></script>
<script>
    const seriesEpisodes = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.SeriesEpisodes));
    const startBtn = document.getElementById('startBtn');
    const statusPre = document.getElementById('statusPre');
    const seriesIdSelect = document.getElementById('SeriesId');
    const episodeIdSelect = document.getElementById('EpisodeId');
    const startSeriesEpisodeBtn = document.getElementById('startSeriesEpisodeBtn');
    const seriesEpisodeError = document.getElementById('seriesEpisodeError');

    const stateSeriesIdSelect = document.getElementById('StateSeriesId');
    const stateEpisodeIdSelect = document.getElementById('StateEpisodeId');
    const startStateSeriesEpisodeBtn = document.getElementById('startStateSeriesEpisodeBtn');
    const startStateSeriesEpisodeAutoBtn = document.getElementById('startStateSeriesEpisodeAutoBtn');
    const stateSeriesEpisodeError = document.getElementById('stateSeriesEpisodeError');

    const stateStoryIdInput = document.getElementById('StateStoryId');
    const startStateNextChunkBtn = document.getElementById('startStateNextChunkBtn');
    const stateNextChunkError = document.getElementById('stateNextChunkError');
    let pollInterval = null;
    let connection = null;

    // helper: fetch and render history for a genId
    async function loadHistory(id) {
        try {
            const p = await fetch(`?handler=progress&id=${encodeURIComponent(id)}`);
            if (!p.ok) return;
            const js = await p.json();
            renderMessages(js.messages);
            if (js.completed) {
                appendMessage('âœ… Completato.');
                if (js.result) appendMessage('Risultato finale (estratto):\n' + js.result.substring(0,1000), 'result');
            }
        } catch (e) { console.error(e); }
    }

    // open a SignalR connection and join a group for genId
    async function connectSignalRAndJoin(genId) {
        try {
            // prefer to reuse the global appSignalR connection if available
            if (window.appSignalR && window.appSignalR.connection) {
                connection = window.appSignalR.connection;
                connection.on('ProgressAppended', (id, message, extraClass) => {
                    if (id !== genId) return;
                    appendMessage(message, extraClass);
                });
                connection.on('ProgressCompleted', (id, finalResult) => {
                    if (id !== genId) return;
                    appendMessage('âœ… Completato.');
                    if (finalResult) appendMessage('Risultato finale (estratto):\n' + (finalResult.substring ? finalResult.substring(0,1000) : finalResult), 'result');
                });
                // Multi-step events
                connection.on('StepProgress', (id, current, max, stepDesc) => {
                    if (id !== genId) return;
                    updateProgressBar(current, max, stepDesc);
                });
                connection.on('StepRetry', (id, retryCount, reason) => {
                    if (id !== genId) return;
                    appendMessage(`ðŸ”„ Retry ${retryCount}: ${reason}`, 'warning');
                });
                connection.on('StepComplete', (id, stepNum) => {
                    if (id !== genId) return;
                    appendMessage(`âœ… Step ${stepNum} completed`, 'success');
                });
                connection.on('TaskComplete', (id, status) => {
                    if (id !== genId) return;
                    hideProgressBar();
                    if (status === 'completed') {
                        appendMessage('âœ… Task completed successfully', 'success');
                    } else if (status === 'failed') {
                        appendMessage('âŒ Task failed', 'error');
                    } else if (status === 'cancelled') {
                        appendMessage('âš ï¸ Task cancelled', 'warning');
                    }
                });
                await window.appSignalR.joinGroup(genId);
                return;
            }
            if (!window.signalR) {
                console.warn('SignalR not available');
                return;
            }
            connection = new signalR.HubConnectionBuilder().withUrl('/progressHub').withAutomaticReconnect().build();

            connection.on('ProgressAppended', (id, message, extraClass) => {
                if (id !== genId) return;
                appendMessage(message, extraClass);
            });
            connection.on('ProgressCompleted', (id, finalResult) => {
                if (id !== genId) return;
                appendMessage('âœ… Completato.');
                if (finalResult) appendMessage('Risultato finale (estratto):\n' + (finalResult.substring ? finalResult.substring(0,1000) : finalResult), 'result');
            });
            // Multi-step events
            connection.on('StepProgress', (id, current, max, stepDesc) => {
                if (id !== genId) return;
                updateProgressBar(current, max, stepDesc);
            });
            connection.on('StepRetry', (id, retryCount, reason) => {
                if (id !== genId) return;
                appendMessage(`ðŸ”„ Retry ${retryCount}: ${reason}`, 'warning');
            });
            connection.on('StepComplete', (id, stepNum) => {
                if (id !== genId) return;
                appendMessage(`âœ… Step ${stepNum} completed`, 'success');
            });
            connection.on('TaskComplete', (id, status) => {
                if (id !== genId) return;
                hideProgressBar();
                if (status === 'completed') {
                    appendMessage('âœ… Task completed successfully', 'success');
                } else if (status === 'failed') {
                    appendMessage('âŒ Task failed', 'error');
                } else if (status === 'cancelled') {
                    appendMessage('âš ï¸ Task cancelled', 'warning');
                }
            });

            await connection.start();
            await connection.invoke('JoinGroup', genId);
        } catch (e) { console.error('SignalR connect error', e); }
    }

    startBtn.addEventListener('click', async () => {
        const prompt = document.getElementById('Prompt').value;
        const genError = document.getElementById('genError');
        if (!prompt || prompt.trim().length === 0) {
            if (genError) {
                genError.textContent = 'Inserisci il prompt';
                genError.style.display = 'block';
            }
            document.getElementById('Prompt').focus();
            return;
        } else if (genError) {
            genError.textContent = '';
            genError.style.display = 'none';
        }

        // save title/prompt to cookie-based history
        saveStoryToCookie();
        clearMessages();
        appendMessage('ðŸŸ¡ Avvio...');
    // send start request (include antiforgery token automatically by using the form)
    const form = document.getElementById('genForm');
    const fd = new FormData(form);
    const res = await fetch('?handler=start', { method: 'POST', body: fd });
        if (!res.ok) {
            const text = await res.text();
            appendMessage('Errore avvio: ' + text, 'error');
            return;
        }
        const data = await res.json();
        const id = data.id;
        // persist last gen id so user can come back to page and reconnect
        try { localStorage.setItem('lastGenId', id); } catch { }
        appendMessage('ðŸŸ¢ Generazione avviata. id: ' + id);
        // load history and start SignalR for live updates
        await loadHistory(id);
        await connectSignalRAndJoin(id);
    });

    function renderEpisodeOptions() {
        if (!seriesIdSelect || !episodeIdSelect) return;
        const serieId = parseInt(seriesIdSelect.value || '0', 10);
        episodeIdSelect.innerHTML = '';
        const items = seriesEpisodes.filter(e => e.SerieId === serieId);
        if (items.length === 0) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'Nessun episodio';
            episodeIdSelect.appendChild(opt);
            return;
        }
        items.forEach(ep => {
            const opt = document.createElement('option');
            opt.value = ep.Id;
            const title = ep.Title ? ` - ${ep.Title}` : '';
            opt.textContent = `Ep ${ep.Number}${title}`;
            if (ep.Id === @Model.EpisodeId) opt.selected = true;
            episodeIdSelect.appendChild(opt);
        });
    }

    function renderStateEpisodeOptions() {
        if (!stateSeriesIdSelect || !stateEpisodeIdSelect) return;
        const serieId = parseInt(stateSeriesIdSelect.value || '0', 10);
        stateEpisodeIdSelect.innerHTML = '';
        const items = seriesEpisodes.filter(e => e.SerieId === serieId);
        if (items.length === 0) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'Nessun episodio';
            stateEpisodeIdSelect.appendChild(opt);
            return;
        }
        items.forEach(ep => {
            const opt = document.createElement('option');
            opt.value = ep.Id;
            const title = ep.Title ? ` - ${ep.Title}` : '';
            opt.textContent = `Ep ${ep.Number}${title}`;
            if (ep.Id === @Model.StateEpisodeId) opt.selected = true;
            stateEpisodeIdSelect.appendChild(opt);
        });
    }

    if (seriesIdSelect) {
        seriesIdSelect.addEventListener('change', renderEpisodeOptions);
        renderEpisodeOptions();
    }

    if (stateSeriesIdSelect) {
        stateSeriesIdSelect.addEventListener('change', renderStateEpisodeOptions);
        renderStateEpisodeOptions();
    }

    if (startSeriesEpisodeBtn) {
        startSeriesEpisodeBtn.addEventListener('click', async () => {
            if (seriesEpisodeError) {
                seriesEpisodeError.textContent = '';
                seriesEpisodeError.style.display = 'none';
            }
            clearMessages();
            appendMessage('Avvio episodio serie...');

            const form = document.getElementById('seriesEpisodeForm');
            const fd = new FormData(form);
            const res = await fetch('?handler=StartSeriesEpisode', { method: 'POST', body: fd });
            if (!res.ok) {
                const text = await res.text();
                if (seriesEpisodeError) {
                    seriesEpisodeError.textContent = text;
                    seriesEpisodeError.style.display = 'block';
                }
                appendMessage('Errore avvio: ' + text, 'error');
                return;
            }
            const data = await res.json();
            const id = data.id;
            try { localStorage.setItem('lastGenId', id); } catch { }
            appendMessage('Generazione episodio avviata. id: ' + id);
            await loadHistory(id);
            await connectSignalRAndJoin(id);
        });
    }

    if (startStateSeriesEpisodeBtn) {
        startStateSeriesEpisodeBtn.addEventListener('click', async () => {
            if (stateSeriesEpisodeError) {
                stateSeriesEpisodeError.textContent = '';
                stateSeriesEpisodeError.style.display = 'none';
            }
            clearMessages();
            appendMessage('Avvio episodio state-driven...');

            const form = document.getElementById('stateSeriesEpisodeForm');
            const fd = new FormData(form);
            const res = await fetch('?handler=StartStateSeriesEpisode', { method: 'POST', body: fd });
            if (!res.ok) {
                const text = await res.text();
                if (stateSeriesEpisodeError) {
                    stateSeriesEpisodeError.textContent = text;
                    stateSeriesEpisodeError.style.display = 'block';
                }
                appendMessage('Errore avvio: ' + text, 'error');
                return;
            }
            const data = await res.json();
            const id = data.id;
            const storyId = data.storyId;
            try { localStorage.setItem('lastGenId', id); } catch { }
            if (storyId) {
                try { localStorage.setItem('lastStateStoryId', storyId.toString()); } catch { }
                if (stateStoryIdInput) stateStoryIdInput.value = storyId;
                appendMessage('StoryId: ' + storyId);
            }
            appendMessage('Generazione episodio state-driven avviata. id: ' + id);
            await loadHistory(id);
            await connectSignalRAndJoin(id);
        });
    }

    if (startStateSeriesEpisodeAutoBtn) {
        startStateSeriesEpisodeAutoBtn.addEventListener('click', async () => {
            if (stateSeriesEpisodeError) {
                stateSeriesEpisodeError.textContent = '';
                stateSeriesEpisodeError.style.display = 'none';
            }
            clearMessages();
            appendMessage('Avvio episodio completo state-driven...');

            const form = document.getElementById('stateSeriesEpisodeForm');
            const fd = new FormData(form);
            const res = await fetch('?handler=StartStateSeriesEpisodeAuto', { method: 'POST', body: fd });
            if (!res.ok) {
                const text = await res.text();
                if (stateSeriesEpisodeError) {
                    stateSeriesEpisodeError.textContent = text;
                    stateSeriesEpisodeError.style.display = 'block';
                }
                appendMessage('Errore avvio: ' + text, 'error');
                return;
            }
            const data = await res.json();
            const id = data.id;
            const storyId = data.storyId;
            try { localStorage.setItem('lastGenId', id); } catch { }
            if (storyId) {
                try { localStorage.setItem('lastStateStoryId', storyId.toString()); } catch { }
                if (stateStoryIdInput) stateStoryIdInput.value = storyId;
                appendMessage('StoryId: ' + storyId);
            }
            appendMessage('Generazione episodio completo accodata. id: ' + id);
            await loadHistory(id);
            await connectSignalRAndJoin(id);
        });
    }

    if (startStateNextChunkBtn) {
        startStateNextChunkBtn.addEventListener('click', async () => {
            if (stateNextChunkError) {
                stateNextChunkError.textContent = '';
                stateNextChunkError.style.display = 'none';
            }
            clearMessages();
            appendMessage('Generazione chunk successivo...');

            const form = document.getElementById('stateNextChunkForm');
            const fd = new FormData(form);
            const res = await fetch('?handler=StateNextChunk', { method: 'POST', body: fd });
            if (!res.ok) {
                const text = await res.text();
                if (stateNextChunkError) {
                    stateNextChunkError.textContent = text;
                    stateNextChunkError.style.display = 'block';
                }
                appendMessage('Errore: ' + text, 'error');
                return;
            }

            const data = await res.json();
            const id = data.id;
            try { localStorage.setItem('lastGenId', id); } catch { }
            appendMessage('Chunk accodato. id: ' + id);
            await loadHistory(id);
            await connectSignalRAndJoin(id);
        });
    }

    // Full Pipeline button - generates with all writers, evaluates, selects best, runs full audio pipeline
    const fullPipelineBtn = document.getElementById('fullPipelineBtn');
    fullPipelineBtn.addEventListener('click', async () => {
        const prompt = document.getElementById('Prompt').value;
        const genError = document.getElementById('genError');
        if (!prompt || prompt.trim().length === 0) {
            if (genError) {
                genError.textContent = 'Inserisci il prompt';
                genError.style.display = 'block';
            }
            document.getElementById('Prompt').focus();
            return;
        } else if (genError) {
            genError.textContent = '';
            genError.style.display = 'none';
        }

        // save title/prompt to cookie-based history
        saveStoryToCookie();
        clearMessages();
        appendMessage('ðŸŽ¬ Avvio pipeline completo...');
        appendMessage('ðŸ“ VerrÃ  generata una storia con tutti i writer attivi');
        appendMessage('ðŸ” Le storie verranno valutate e la migliore selezionata');
        appendMessage('ðŸ”Š Poi verrÃ  eseguito il pipeline audio completo');

        // send start request for full pipeline
        const form = document.getElementById('genForm');
        const fd = new FormData(form);
        const res = await fetch('?handler=StartFullPipeline', { method: 'POST', body: fd });
        if (!res.ok) {
            const text = await res.text();
            appendMessage('Errore avvio: ' + text, 'error');
            return;
        }
        const data = await res.json();
        const id = data.id;
        // persist last gen id so user can come back to page and reconnect
        try { localStorage.setItem('lastGenId', id); } catch { }
        appendMessage('ðŸŸ¢ Pipeline completo avviato. id: ' + id);
        // load history and start SignalR for live updates
        await loadHistory(id);
        await connectSignalRAndJoin(id);
    });

    // on page load, if there's a lastGenId in localStorage, reattach to it (so the page is persistent)
    (async () => {
        // render any saved stories from cookie
        renderSavedButtons();
        try {
            const existing = localStorage.getItem('lastGenId');
            if (existing) {
                clearMessages();
                appendMessage('ðŸ”„ Ricollegamento alla generazione ' + existing + '...');
                await loadHistory(existing);
                await connectSignalRAndJoin(existing);
            }

            const lastStateStoryId = localStorage.getItem('lastStateStoryId');
            if (lastStateStoryId && stateStoryIdInput && (!stateStoryIdInput.value || stateStoryIdInput.value.trim().length === 0)) {
                stateStoryIdInput.value = lastStateStoryId;
            }
        } catch (e) { console.error(e); }
    })();
    // message helpers
    function clearMessages() { statusPre.innerHTML = ''; }
    function appendMessage(msg, extraClass) {
        const el = document.createElement('div');
        el.className = 'status-msg' + (extraClass ? (' ' + extraClass) : '');
        
        // Apply pastel colors for success/error
        if (extraClass === 'success') {
            el.style.backgroundColor = '#d4edda';
            el.style.color = '#155724';
            el.style.padding = '8px';
            el.style.borderRadius = '4px';
            el.style.marginBottom = '4px';
        } else if (extraClass === 'error') {
            el.style.backgroundColor = '#f8d7da';
            el.style.color = '#721c24';
            el.style.padding = '8px';
            el.style.borderRadius = '4px';
            el.style.marginBottom = '4px';
        } else if (extraClass === 'warning') {
            el.style.backgroundColor = '#fff3cd';
            el.style.color = '#856404';
            el.style.padding = '8px';
            el.style.borderRadius = '4px';
            el.style.marginBottom = '4px';
        }
        
        el.textContent = msg;
        statusPre.appendChild(el);
    }
    function renderMessages(messages) { clearMessages(); if (!messages) return; messages.forEach(m => appendMessage(m)); }

    // Progress bar helpers
    function updateProgressBar(current, max, stepDesc) {
        const progressDiv = document.getElementById('multiStepProgress');
        const progressBar = document.getElementById('progressBar');
        const stepStatus = document.getElementById('stepStatus');
        
        if (progressDiv && progressBar && stepStatus) {
            progressDiv.style.display = 'block';
            const pct = Math.round((current / max) * 100);
            progressBar.style.width = pct + '%';
            progressBar.textContent = `Step ${current}/${max}`;
            stepStatus.textContent = stepDesc;
        }
    }

    function hideProgressBar() {
        const progressDiv = document.getElementById('multiStepProgress');
        if (progressDiv) {
            progressDiv.style.display = 'none';
        }
    }

    // --- Saved stories (cookie) helpers ---
    function getCookie(name) {
        const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
        return v ? decodeURIComponent(v.pop()) : '';
    }
    function setCookie(name, value, days) {
        const d = new Date();
        d.setTime(d.getTime() + (days*24*60*60*1000));
        document.cookie = name + '=' + encodeURIComponent(value) + ';path=/;expires=' + d.toUTCString();
    }
    function getSavedStories() {
        const raw = getCookie('tg_history');
        if (!raw) return [];
        try { return JSON.parse(raw); } catch (e) { return []; }
    }
    function saveStoryToCookie() {
        try {
            const titleEl = document.getElementById('Title');
            const promptEl = document.getElementById('Prompt');
            if (!titleEl || !promptEl) return;
            const title = titleEl.value ? titleEl.value.trim() : '';
            const prompt = promptEl.value ? promptEl.value : '';
            if (!title) return; // don't save empty titles
            const arr = getSavedStories();
            // if title exists, remove it (we'll re-add to front)
            const idx = arr.findIndex(x => x.title === title);
            if (idx >= 0) arr.splice(idx, 1);
            arr.unshift({ title: title, prompt: prompt });
            // keep max 10
            const sliced = arr.slice(0, 10);
            setCookie('tg_history', JSON.stringify(sliced), 365);
            renderSavedButtons();
        } catch (e) { console.error('saveStoryToCookie', e); }
    }
    function renderSavedButtons() {
        const container = document.getElementById('savedStories');
        if (!container) return;
        container.innerHTML = '';
        const arr = getSavedStories();
        if (!arr || arr.length === 0) return;
        arr.forEach(item => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'action-btn';
            btn.style.padding = '6px 10px';
            btn.style.background = '#f1f5f9';
            btn.style.border = '1px solid #e2e8f0';
            btn.style.borderRadius = '6px';
            btn.style.cursor = 'pointer';
            btn.textContent = item.title;
            btn.title = 'Ripristina titolo e prompt salvati';
            btn.addEventListener('click', () => {
                const titleEl = document.getElementById('Title');
                const promptEl = document.getElementById('Prompt');
                if (titleEl) titleEl.value = item.title;
                if (promptEl) promptEl.value = item.prompt;
            });
            container.appendChild(btn);
        });
    }

    // hide error when user edits prompt
    const promptInput = document.getElementById('Prompt');
    if (promptInput) {
        promptInput.addEventListener('input', () => {
            const genError = document.getElementById('genError');
            if (genError) { genError.textContent = ''; genError.style.display = 'none'; }
        });
    }
</script>
